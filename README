/******************************************************************************
(A) Title and Author
* Title: COMP 15 Project 1 TypeWriter
* README
* Author: Tadhg Murray (tmurra01)
* Date: 2/20/26
******************************************************************************/


(B)Program Purpose:
---------------

    This program defines, implements, and tests a stack of Action objects.
    This stack supports adding/removing/getting elements at the top, getting
    the size/is the stack empty, and clearing the entire stack.


(C)Acknowledgments:
---------------

    I received help in completing this assignment through the lecture on
    2/8/26 about stacks, which helped me write the ActionStack class. The lab
    on stacks also helped me to further learn about how to implent stacks,
    by seeing the code used in the lab. I also
    received help from the TA who went over my implementation design with me,
    which helped me learn about some edgecases of the undo and redo stacks.
    I received some assistance for the vector operations I used in the 
    ActionStack class from GeeksForGeeks vector operations documentation.



(D)Files:
-----

    ActionStack.cpp: Implementation of ActionStack class

    ActionStack.h: Interface of ActionStack class

    unit_tests.h: Unit tests for the ActionStack class

    README: This file


(E)Compile/run:
-----------

    Compile and run the unit tests using unit_test.
    Use Make to compile the program. Use ./TypeWriter textfile [logfile]
    to run the program.


(F)Data Structures and Algorithms:
------------------------------

    Data Structures Used:
    
    The ADT used in this project is a stack that supports adding/removing
    elements at the top, getting the top element, and clearing the entire 
    stack. This ADT was implemented through an arraylist, specifically
    the vector class. I used that data structure because it had o(1) time
    complexity for adding/removing/getting elements at the end, which is
    how you add/remove/get elements in the stack ADT. It also provides
    expansion through the array growing as needed and simplifies the data 
    storage through contiguous storage in the array. The main disadvantages
    of this implementation was that resizing the array required reallocating
    the memory and copying the elements, which is O(n) time complexity. There
    is also potential wasted memory due to the capacity of the stack being
    larger than its size. A good place for this data structure to be used
    could be checking if brackets are matched correctly(like the compiler 
    does). This is because it only need to access the top element.
    
    Algorithm Overview:

    Removal algorithm - this is the algorithm used in the pop() and clear()
    functions. I found this algorithm interesting because I could use the
    same algorithm for multiple functions, which allowed me to really only
    make one function that used the algorithm, while the other functions
    called that one, increasing modularity.

    Insert algorithm

    Access algorithm


(G)Testing:
-------

    For each function I wrote I would then unit test it immediately after.
    I started out by writing the isEmpty(), then size(), and then the push()
    function, because these were required to write all of the other unit tests.
    I would unit test each function by testing it on an empty stack, a one
    element stack, and a 100 element stack, when applicable. For the pop()/
    push()/clear() functions I would test them by doing them one time and a
    100 times, and I would test them on different sizes of stacks.


(I)Hours Spent: 5 hours